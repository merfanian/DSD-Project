\chapter{مقدمه}
\noindent
\textbf{
\textit{
توضیحی اولیه مشتمل بر تعریف الگوریتم، نحوه کلی عملکرد الگوریتم، پایه‌های ریاضی، کاربردها و استانداردها
}
}
\pagebreak
\section{توضیح الگوریتم}
\par
الگوریتمی که در ادامهٔ این مستند شرح و توضیح آن آمده است الگوریتم درهم سازی 
\lr{skein}
یا 
\lr{skein hash function}
است. این الگوریتم از سری الگوریتم‌های درهم‌سازی امنیتی یا 
\lr{cryptographic hash function}
 و یکی از نامزدهای نهایی مسابقه انتخاب بهترین تابع درهم‌سازی 
 \lr{NIST}
 می‌باشد. این مسابقه برای انتخاب بهترین الگوریتم در‌هم‌سازی برای استاندارد جدید 
 \lr{SHA-3}
 برگزار شد. 
 طبق ادعای طراحان الگوریتم این الگوریتم می‌تواند در 
 \lr{6.1}
 کلاک در بایت داده‌ها را هش کند، که به این معنیست که در پردازندهٔ دوهسته‌ای
 \lr{64}
  بیتی با فرکانس پردازشی
\lr{3.1 GHz}
    می‌تواند با سرعت 
\lr{500}
  مگابایت بر ثانیه داده‌ها را هش کند. این مقدار سرعت تقریبا دوبرابر سرعت هش کردن دادهٔ الگوریتم 
  \lr{ SHA-512}
  است. همچنین با گزینه درخت درهم‌سازی که می‌تواند به صورت اختیازی در الگوریتم پیاده‌سازی شود می‌توان 	در پیاده‌سازی موازی الگوریتم سرعت را به بیش از این هم رساند. نکته دیگری که در مورد الگوریتم 
  \lr{skein}
  لازم به ذکر است این است که این الگوریتم پیاده‌سازی آسان و ساده‌ای دارد و فقط از سه عمل‌گر اصلی برای محاسبه هش استفاده می‌کند و نحوهٔ عملکرد الگوریتم به راحتی قابل به خاطرسپاری و یادگیری‌ست. 
  \par
  الگوریتم درهم‌سازی
  \lr{skein}
  برای حالت‌های ورودی ۲۵۶، ۵۱۲ و ۱۰۲۴ بایتی و هرمقداری خروجی پیاده‌سازی شده است که این خاصیت در انعطاف الگوریتم در حالت‌های مختلف بسیار حیاتی‌ست. 
  \\
  در پیاده‌سازی سخت‌افزاری نیز این الگوریتم قوی عمل می‌کند،‌برای پیاده‌سازی 
  \lr{skein-512}
  بر سخت‌افزار به حدود ۲۰۰ بایت فضای مموری نیاز داریم، برای 
  \lr{skein-256}
  این مفدار به حدود ۱۰۰ بایت کاهش پیاده می‌کند که این الگوریتم را به یک الگوریتم مناسب برای پیاده‌سازی‌های روی قطعات کوچک سخت‌افزاری تبدیل می‌کند، مثلا می‌توان از 
  \lr{skein-256}
  در پیاده‌سازی 
  \lr{smart card}
  استفاده کرد.
  \cite{skein}
 
  
  \subsection{مثال‌هایی از درهم‌سازی}

	\begin{itemize}
	
	\item \lr{Skein-256-256("")}\\
$c8877087da56e072870daa843f176e9453115929094c3a40c463a196c29bf7ba$
\item \lr{Skein-512-256("")}\\
$39ccc4554a8b31853b9de7a1fe638a24cce6b35a55f2431009e18780335d2621$
\item \lr{Skein-512-512("")}\\
$bc5b4c50925519c290cc634277ae3d6257212395cba733bbad37a4af0fa06af4$\\
$1fca7903d06564fea7a2d3730dbdb80c1f85562dfcc070334ea4d1d9e72cba7a$

	\end{itemize}
	
\section{مختصری دربارهٔ الگوریتم‌های درهم‌سازی امنیتی}
در دنیای امروز الگوریتم‌های درهم‌سازی امنیتی تقریبا در تمامی نقاط مختلفی که با اینترنت سر و کار دارند پیدا می‌شوند، بزرگ‌ترین کاربرد این الگوریتم‌ها ایجاد امضای دیجیتالی یا 
\lr{digital signature}
است که در ذخیرهٔ رمزهای عبور، اتصالات امنیتی به سرورها، مدیریت رمزنگاری‌ها و اسکن ویروس‌ها و بدافزارها به کار می‌رود، تقریبا تمامی پروتکل‌های امنیتی در دنیای اینترنت امروز بدون الگوریتم‌های درهم‌سازی امنیتی به سختی قابل پیاده‌سازی خواهند بود. 
\par
بزرگترین الگوریتم‌های درهم‌سازی امنیتی فعلی الگوریتم‌های خانواده 
\lr{SHA}
می‌باشند، الگوریتم‌های خانواده 
\lr{SHA}
به اختصار نام موارد زیر اند.
\begin{itemize}
\item
	\lr{SHA-0}
	\item
	\lr{SHA-1}
	\item
	\lr{SHA-256}
	\item
	\lr{SHA-512}
\end{itemize}
تمامی موارد بالا از روی الگوریتم‌های 
\lr{MD4} 	و
\lr{MD5}
اقتباس شده اند. 
در سال‌های اخیر کاستی‌ها و مشکلات امنیتی زیادی در الگوریتم‌های 
\lr{MD4, MD5, SHA-0, SHA-1}
یافت شدند اما هنوز باگ امنیتی بزرگی برای الگوریتم‌های 
\lr{SHA-256, SHA-512}
یافت نشده است اما به دلیل وابستگی زیاد صنعت و امنیت فعلی اطلاعات به الگوریتم‌های درهم‌سازی در سال ۲۰۱۲ 
تصمیم بر این شد تا جایگزین مناسب و جدیدی برای الگوریتم‌های 
\lr{SHA-256, SHA-512}
انتخاب شود تا در صورتی که این الگوریتم‌ها شکسته شدند به سرعت الگوریتم‌های جدید در قالب نام 
\lr{SHA-3}
جایگزین شوند. 
\section{هدف الگوریتم درهم‌سازی skein}	
هدف الگوریتم درهم‌سازی skein مانند دیگر الگوریتم‌های درهمسازی امنیتی ایجاد یک تابع برای درهم‌سازی داده‌های مختلف است به شکلی که ویژگی‌ها زیر برای آنان برقرار باشند.

\begin{itemize}
\item قطعی بودن:
به شکلی که به ازای ورودی یکسان مقدار در‌هم‌سازی با تکرار الگوریتم برابر باشد، مثلا با دادن ورودی "salam" به صورت متوالی به تابع مقدار هش تغییر نکند. 
\item یک طرفه بودن:
نتوان از مقدار خروحی مقدار ورودی را یافت. 
\item
یک به یک بودن:
نتوان دو ورودی پیدا کرد به شکلی که به ازای این دو ورودی مقدار خروجی مساوی شود.
\item حساس بودن:
با تغییر اندک در ورودی خروجی به شکل قابل ملاحظه‌ای تفییر کند تا مقدار هش قابل حدس زدن نباشد.
\item
سریع بودن: 
الگوریتم باید بتواند هش را در مدت زمانی کوتاهی حساب کند تا به کاربردی بودن برسد.

\end{itemize}


\section{نحوهٔ کلی عملکرد الگوریتم}
ایدهٔ اصلی الگوریتم بر ایجاد بلوک‌های زمزگذاری قابل تنظیم یا به زبان نویسندگان الگوریتم
\lr{tweakable block cipher}
بنا نهاده شده است؛ به صورت دقیق‌تر می‌توان گفت که
Skein 
از سه قسمت اصلی زیر تشکیل شده است و برای درهم‌سازی از ایشان استفاده می‌کند.
\begin{itemize}
\item
\lr{\textbf{Threefish}}\\
این قسمت یک بلوک رمزگذاری قابل تنظیم است که در هسته اصلی الگوریتم پیاده‌سازی شده است، این بلوک‌ها در سایزهای ۲۵۶، ۵۱۲، ۱۰۲۴ بیتی تعریف شده اند.
\item
\lr{\textbf{Unique Block Iteration (UBI)}}\\
\lr{UBI}
یک حالت زنجیری‌ست که با استفاده از بلوک قبلی به عنوان ورودی خود سعی در ایجاد یک الگوریتم فشرده‌سازی مخصوص ورودی می‌کند که بلوک ورودی با سایز دلخواه را به یک خروحی با سایز مشخص تبدیل کند.
\item
\lr{\textbf{Optional Argument System}}\\
این ویژگی به الگوریتم اجازه می‌دهد تا از تعدادی ویژگی اختیاری بدون تحمیل هزینه بیش از حد اجرایی استفاده کند. 
\cite{main_doc}
\end{itemize}
	
\begin{thebibliography}{1}


\bibitem{skein}{
\lr{
http://www.skein-hash.info/about\\
  }}
  
  \bibitem{main_doc}
  \lr{The Skein Hash Function Family\\
Version 1.3 — 1 Oct 2010\\
http://www.skein-hash.info/sites/default/files/skein1.3.pdf\\
}
  
\end{thebibliography}
